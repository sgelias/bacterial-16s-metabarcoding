---
title: "Analysis of Bacterial metabarcoding sequencing results"
output:
  html_document:
    df_print: paged
    number_sections: true
    keep_md: yes
    theme: cerulean
    toc: yes
    css: "style.css"
params:
  dataset: dataset
  taxonomy: taxonomy
  exp_design: exp_design
  main_factor: main_factor
  is_docker: is_docker
  cores: cores
---


```{r load-initial-variables, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}

# Define default parameters if is not running inside a Docker environment
if (params$is_docker == TRUE) {
  RAM_path = "/home/scripts/src/RAM.R"
  dataset_path = params$dataset
  design_path = params$exp_design
  main_factor = params$main_factor
  taxonomy_path = params$taxonomy
  host_cores = params$cores
} else {
  RAM_path = "./src/RAM.R"
  dataset_path = "../../data/output_tables/otu_table_tax_amostras.tsv"
  design_path = "../../data/metadata.tsv"
  main_factor = "time"
  taxonomy_path = "../../data/output_tables/tax_table_amostras.tsv"
  host_cores = 6
}

```


```{r load-dependencies, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}

source("./packages.R")
source(RAM_path)

```



# Base data

## OTU table

```{r load-main-dataset, echo=FALSE, rows.print=25}

# Load table from specified path
dataset <- read.csv(dataset_path, sep = "\t")

# Rename unused part of column names (samples)
col_names <- colnames(dataset)

for (v in seq_along(col_names)) {
  if (col_names[v] != "OTU") {
    col_names[v] = strsplit(col_names[v], split = "_")[[1]][1]
  }
}

colnames(dataset) = col_names

datatable(
  dataset, class = 'cell-border stripe', options = list(scrollX = '100%'))

```



## Taxonomy table

```{r load-taxonomy, echo=FALSE, rows.print=20, out.width=30}

taxonomy <- read.csv(taxonomy_path, sep = "\t")
datatable(taxonomy, class = 'cell-border stripe')

```



## Experimental design

```{r load-experimental-design, echo=FALSE, rows.print=20, out.width=30}

design <- read.csv(design_path, sep = "\t")
datatable(design, class = 'cell-border stripe')

```



# Descriptive statistics

## List of the 50th most abundant bacterial OTU's

```{r create-populate-most-abundant-otus, echo=FALSE, warning=FALSE, message=FALSE}

# Create the function to populate the most abundant bacterial OTUs
#' Render a list of htmlWidgets using various tricks
#' source https://stackoverflow.com/a/33222656
#' 
#' @param dataset A list of htmlWidget objects to be rendered
#' @param renderFunction The function to render individual widgets. It can be either a name
#'   of the rendering function, e.g., "render_graph" in DiagrammeR, or the actual function to
#'   be passed to this call.
#' @return The knitted string. This is to be included in the output by using `r renderHtmlWidgetList(...)`;
#' @details This is a collection of various tricks. See the URL citations in the code.
#'   Note that this code does alliterate global variables starting with "renderHtmlWidgetList_".
#'   You may want to delete them using rm(list = ls(pattern="renderHtmlWidgetList_*")).
#' @examples Inlcude the following in the Rmd directly
#'   `r require(DiagrammeR); renderHtmlWidgetList(grfDf$graph, render_graph)`
#'
#' @export

get_most_abundant_otu <- function(dataset, meta) {
  
  # Initialize base data.frame
  most_abundant_otu_df = data.frame(matrix(ncol = 5))
  colnames(most_abundant_otu_df) = c("OTU", "count", colnames(meta))
  
  # Populate the 50th most abundant OTU from each sample
  for (column in 1:dim(dataset)[2]) {
    cname = colnames(dataset)[column]
    
    if (cname != "OTU") {
      
      local_most_abundant_otu_df = cbind(
        dataset %>%
          select("OTU", cname) %>%
          arrange(desc(!!sym(cname))) %>%
          slice_head(n = 50) %>%
          rename(count = cname),
        design %>%
          filter(group == cname)
      )
      
      most_abundant_otu_df = rbind(most_abundant_otu_df, local_most_abundant_otu_df)
    }
  }
  
  return(na.omit(most_abundant_otu_df))
}

```



```{r populate-most-abundant-otus, echo=FALSE, warning=FALSE, message=FALSE, rows.print=25}

# Get the most abundant bacterial OTUs
most_abundant_otu_df <- get_most_abundant_otu(dataset, design)

# Concatenate the OTU and count columns to show it in girafe tooltip
most_abundant_otu_df$tooltip <- paste0(
  most_abundant_otu_df$OTU, " | ", most_abundant_otu_df$count
)

# Print the resulting dataframe ordered by count columns
datatable(
  arrange(most_abundant_otu_df, desc(count)), class = 'cell-border stripe')

```



## Plot the 50th most abundant bacterial OTU's

```{r plot-most-abundant-otu-absolute, fig.height=14, fig.width=14, echo=FALSE}

barplot_grouped_absolute <- most_abundant_otu_df %>% 
  
  # Create the graph base
  ggplot(aes(x = group, y = count, fill = OTU)) +
  
  # Set the plot theme
  theme_classic() +
  
  # Replace the group legend
  theme(legend.position = "bottom", legend.box = "vertical") +
  
  # Add reference lines
  geom_hline(yintercept = 5000, size = 0.5, color = "grey70") +
  geom_hline(yintercept = 10000, size = 0.5, color = "grey70") +
  
  # Convert the graph to a interactive mode
  geom_bar_interactive(
    position = "stack",
    stat = "identity", 
    colour = "white",
    size = 0.1,
    aes(tooltip = tooltip)
  ) +
  
  # Convert the colour gradient from continuous to discrete
  scale_fill_viridis(discrete = T) +
  
  # Wrap the graph from main factor
  facet_wrap(as.formula(paste("~", main_factor)), scales = "free") +
  
  # Set title and legends
  ggtitle("The 50th most abundant bacterial OTU from each sample.") +
  labs(
    y = "Absolute number or reads", 
    x = "Sample"
  ) +
  
  # Rotate right
  coord_flip()

girafe(
  ggobj = barplot_grouped_absolute,
  width_svg = 16,
  height_svg = 14,
  options = list(
    opts_sizing(width = 1),
    opts_zoom(max = 5)
  )
)

```



## Test the sampling effetiveness using Hill number of order 0 (q0)

```{r refatorate-reference-tables, echo=FALSE, message=FALSE, warning=FALSE, rows.print=30}

# Merge the taxonomic ranks inside the OTU table
populate_taxonomy_from_reference <- function(taxonomy_table, dataset) {
  for (row in 1:dim(dataset)[1]) {
    current_row = dataset[row, ]
    current_taxonomy = taxonomy_table[taxonomy_table$X == current_row$OTU, ]
    dataset[row,"taxonomy"] = paste(
      paste0("k__", current_taxonomy$Domain),
      paste0("p__", current_taxonomy$Phylum),
      paste0("c__", current_taxonomy$Class),
      paste0("o__", current_taxonomy$Order),
      paste0("f__", current_taxonomy$Family),
      paste0("g__", current_taxonomy$Genus),
      sep = "; "
    )
  }
  return(dataset)
}

# Refatorate experinemtal design table
ordination_design <- design
rownames(ordination_design) <- design$group
ordination_design <- ordination_design[ ,-1]
ordination_design[main_factor] <- factor(ordination_design[[main_factor]])

# Refatorate OTU table
ordination_dataset <- populate_taxonomy_from_reference(taxonomy, dataset)
rownames(ordination_dataset) <- dataset$OTU
ordination_dataset <- ordination_dataset[ ,-1]
ordination_dataset <- ordination_dataset[ ,c(rownames(ordination_design), "taxonomy")]

```


```{r generate-rarefaction-results, message=FALSE, echo=FALSE, warning=FALSE, include=FALSE}

# Make cluster
cl <- parallel::makeCluster(host_cores)
doParallel::registerDoParallel(cl)

# Build the function to rarefy to each sample
generate_multiple_rarefaction <- function(abund_table) {
  
  rarefy = foreach(n = 1:dim(abund_table)[2], .packages = "iNEXT") %dopar% {
    iNEXT(
      abund_table[[n]][abund_table[[n]] != 0],
      q = 0,#c(0, 1, 2),
      datatype = "abundance",
      endpoint = length(abund_table[[n]][abund_table[[n]] != 0]),
      se = TRUE,
      conf = 0.95,
      nboot = 50
    )
  }
  
  names(rarefy) = colnames(abund_table)
  
  return(rarefy)
}

multi_q_rare <- generate_multiple_rarefaction(
  ordination_dataset[ ,colnames(ordination_dataset) != "taxonomy"])

# Stop cluster
parallel::stopCluster(cl)

```



### List diversity estimates for all sampling group

```{r populate-rarefaction-results, echo=FALSE, message=FALSE, warning=FALSE, rows.print=25}

# Build function to compile basic rarefaction results
populate_rarefaction_results <- function(rarefaction_list) {
  
  # Initialize a data.frame to store final results
  rarefy_results = data.frame(matrix(ncol = 7))
  colnames(rarefy_results) = c(
    "Sample", "Diversity ", colnames(rarefaction_list[[1]]$AsyEst))
  
  # Populate results
  for (sample in seq_along(multi_q_rare)) {
    sample_estimates = data.frame(rarefaction_list[[sample]]$AsyEst)
    sample_name = rep(names(multi_q_rare[sample]), dim(sample_estimates)[1])
    sample_estimates = cbind(
      sample_name, rownames(sample_estimates), sample_estimates)
    colnames(sample_estimates) = colnames(rarefy_results)
    rarefy_results = rbind(rarefy_results, sample_estimates)
  }
  
  rarefy_results = na.omit(rarefy_results)
  rownames(rarefy_results) = 1:dim(rarefy_results)[1]
  
  return(rarefy_results)
}

datatable(
  populate_rarefaction_results(multi_q_rare), class = 'cell-border stripe')

```



### List and ploting diversity estimates by group

```{r create-plotter-rarefaction-results, fig.height=6, fig.width=12, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}

# Create a function to reuse line layer
custom_line_annotations <- function(axis, intercept) {
  if (axis == "x") {
    g = geom_vline_interactive(
      xintercept = intercept, linetype = "dashed", size = 0.5, color = "grey70",
      tooltip = intercept)
  } else if (axis == "y") {
    g = geom_hline_interactive(
      yintercept = intercept, linetype = "dashed", size = 0.5, color = "grey70",
      tooltip = intercept)
  }
  return(g)
}

# Create function to compile the rarefaction results graph
populate_rarefaction_graphs <- function(title, rarefaction_list) {
  
  # Initialize the data.frame to store the points position
  points_df = data.frame(matrix(ncol = 3))
  colnames(points_df) = c("sample","x", "y")
  
  # Build base graph
  rare_curve <- ggplot() +
    
    # Set theme
    theme_bw() +
    
    # Title and Labels
    ggtitle(title) +
    labs(x = "Number of Species (n)", y = "Species Diversity (qD)") +
    
    # Remove legends
    theme(legend.position = "none", panel.grid.minor = element_blank())
  
  for (item in seq_along(rarefaction_list)) {
    
    # Get the current name of the sample to be populated
    current = names(rarefaction_list[item])
    
    # Populate the points position
    points_df[item,1:3] = c(
      current, 
      filter(rarefaction_list[[current]]$iNextEst, method == "interpolated") %>% 
        select(m) %>% max(), 
      filter(rarefaction_list[[current]]$iNextEst, method == "interpolated") %>% 
        select(qD) %>% max()
    )
    
    # Populate the lines layer
    rare_curve = rare_curve +
      
      # Set graph main geometry
      geom_line(
        data = rarefaction_list[[current]]$iNextEst,
        aes(x = m, y = qD, linetype = factor(method)),
        colour = "grey40",
      )
      
      # Set line types
      scale_linetype_manual(values = c("solid"))
  }
  
  points_df$x = as.numeric(points_df$x)
  points_df$y = as.numeric(points_df$y)
  colnames(points_df) = c("sample", "n", "qD")
  
  # Create limit lines
  geom_line_params = list(linetype = "dashed", size = 0.5, color = "grey80")
  rare_curve = rare_curve + 
    custom_line_annotations("y", max(points_df$qD)) +
    custom_line_annotations("y", min(points_df$qD)) +
    custom_line_annotations("x", max(points_df$n)) +
    custom_line_annotations("x", min(points_df$n))
  
  # Create the interactive label
  rare_curve = rare_curve +
    geom_point_interactive(
      data = points_df,
      aes(x = n, y = qD, tooltip = sample),
      colour = "black",
      size = 5
    )
  
  return(list(
    plot = rare_curve, 
    estimates = points_df
  ))
}

```


```{r plot-rarefaction-curves, warning=FALSE, message=FALSE, results='asis', echo=FALSE}

# Set header and footer of dynamic chunks
knitPrefix <- "\n```{r echo=FALSE, warning=FALSE, message=FALSE}\n"
knitSuffix <- "\n```\n"

# Initialize lists to store charts and tables created dynamically
tables = list()
charts = list()

# Print rarefaction according the main_factor
for (fact in seq_along(unique(ordination_design[[main_factor]]))) {
  
  # Get a single factor of main_factor
  fact_value <- unique(ordination_design[[main_factor]])
  
  # Build message
  message <- paste0("#### Sample effectiveness of ", fact_value[fact], " group")
  
  # Sample the OTU matrix according the factor set
  factor_set <- multi_q_rare[names(multi_q_rare) %in% rownames(
    filter(ordination_design[main_factor], get(main_factor) == fact_value[fact])
  )]
  
  # Build the graph
  rare <- populate_rarefaction_graphs(fact_value[fact], factor_set)
  
  # Render a item title
  cat(knitr::knit_child(text = message, envir = environment(), quiet = TRUE))
  
  # Print table of per-sample estimates
  cat(knitr::knit_child(
    text = c(
      knitPrefix,
      "datatable(rare$estimates, class = 'cell-border stripe')",
      knitSuffix
    ), 
    envir = environment(), 
    quiet = TRUE
  ))
  
  # Print the rarefaction graph
  cat(knitr::knit_child(
    text = c(
      knitPrefix,
      "girafe(
        ggobj = rare$plot,
        options = list(opts_sizing(width = .7), opts_zoom(max = 5))
      )",
      knitSuffix
    ),
    envir = environment(), 
    quiet = TRUE
  ))
}

```



## Explore the samplings relationship (Principal Coordinates Analysis - PCoA)

```{r print-pcoa, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.dim=0.2}

# Generate the base plot
pcoa_plot <- custom_pcoa_plot(
  ordination_dataset, 
  meta = ordination_design, 
  rank = "f",
  factors = c(main_factor = main_factor)
)

pcoa_plot = pcoa_plot + 
  
  # Set the classic theme
  theme_classic() +
  
  # Remove the group legend
  theme(legend.position = "none") +
  
  # Add reference lines
  geom_hline(yintercept = 0, size = 0.5, color = "grey70") +
  geom_vline(xintercept = 0, size = 0.5, color = "grey70") +
  
  # Add a interactive layer
  geom_point_interactive(
    aes(
      tooltip = rownames(ordination_design), 
      color = paste0(main_factor)
    ), 
    size = 7
  ) +
  
  # Set title and legends
  ggtitle("Principal Coordinates Analysis (PCoA).") +
  
  # Convert the colour gradient from continuous to discrete
  scale_fill_viridis(discrete = T)

girafe(
  ggobj = pcoa_plot,
  width_svg = 8,
  height_svg = 8,
  options = list(
    opts_sizing(width = .7),
    opts_zoom(max = 5)
  )
)

```



# Comparative statistics

## Test the statistical significance among the group's species composition

```{r generate-permanova, echo=FALSE, message=FALSE, warning=FALSE}

# Comcatenate experimental design and OTU's table to compose the analysis 
# dataset
adonis_data <- cbind(
  design, t(ordination_dataset[ ,colnames(ordination_dataset) != "taxonomy"]))

# Generate the distance matrix using the Morisita dissimilarity index
dist_bray <- vegdist(
  adonis_data[ ,colnames(adonis_data) != c("group", "dpw", "time")], 
  method = "morisita")

# Generate the PERMANOVA using the main_factor
permanova <- data.frame(
  adonis(dist_bray ~ get(main_factor), adonis_data, permutations = 9999)$aov.tab)

# Rename columns
colnames(permanova) <- c(
  "Df", "Sums. of Sqs.", "Mean. Sqs.", "F. Model", "R2", "Pr(>F)")

permanova

```



## Identify differential abundant bacterial OTUs with edger

### Filter original dataset to include only OTU's with at last 3 observations

```{r build-base-edger-object, echo=FALSE, rows.print=20}

# Create the edger object
dge_dataset <- DGEList(
  counts = ordination_dataset[ ,colnames(ordination_dataset) != "taxonomy"], 
  group = ordination_design[ ,main_factor]
)

original_dataset_dim <- dim(dge_dataset)

# Filter the OTU count table to include only specimens with at last three 
# occurrences
keep <- rowSums(cpm(dge_dataset) > 100) >= 2
dge_dataset <- dge_dataset[keep, ]
filtered_dataset_dim <- dim(dge_dataset)

# Reset the cols count variable
dge_dataset$samples$lib.size <- colSums(dge_dataset$counts)

data_filter_stats <- data.frame(rbind(
  c(original_dataset_dim[1], original_dataset_dim[2]),
  c(filtered_dataset_dim[1], filtered_dataset_dim[2])
))

rownames(data_filter_stats) <- c("Original table size", "Filtered table size")
colnames(data_filter_stats) <- c("OTU's", "Samples")

data_filter_stats

```



### Get estimates of the bacterial OTU's differential abundance

```{r estimate-differential-abundance, rows.print=25, echo=FALSE, message=FALSE, warning=FALSE}

# Compute the tagwise tests using the exact negative binomial test. By default, 
# Benjamini and Hochberg's algorithm is used to control the false discovery 
# rate (FDR).
dge_dispersion <- estimateCommonDisp(dge_dataset, verbose = T)
dge_tag_dispersion <- estimateTagwiseDisp(dge_dispersion)
exact_test <- exactTest(dge_tag_dispersion, pair = c(1,2))
datatable(
  data.frame(topTags(exact_test, n = dim(dge_dataset)[1])), 
  class = 'cell-border stripe')

```



### Get the total number of differentially abundant bacterial OTUs at FDR < 0:05

```{r count-differential-abundant, echo=FALSE, message=FALSE, warning=FALSE}

decide_test <- decideTestsDGE(exact_test, adjust.method = "BH", p.value = 0.05)
decide_test_summary <- data.frame(summary(decide_test))
decide_test_summary <- decide_test_summary[ ,c(1, 3)]
colnames(decide_test_summary) <- c("Direction", "Frequence")
decide_test_summary

```



### Plot the tagwise log-fold-changes against log-cpm

```{r echo=FALSE, message=FALSE, warning=FALSE}

vulcano_data <- cbind(decide_test@.Data, exact_test$table)
colnames(vulcano_data)[1] = "Late_Early"
vulcano_data$Late_Early <- factor(vulcano_data$Late_Early)
vulcano_data$Tooltip <- paste0(
  rownames(vulcano_data), "\n", 
  paste0("logFC: ", round(vulcano_data$logFC, 2)), " | ", 
  paste0("logCPM: ", round(vulcano_data$logCPM, 2))
)

volcano <- ggplot(vulcano_data) +
  
  # Set the plot theme
  theme_classic() +
  
  # Replace the group legend
  theme(legend.position = "top", legend.box = "vertical") +
  
  # Add reference lines
  geom_hline(yintercept = 2, size = 0.5, color = "grey70") +
  geom_hline(yintercept = -2, size = 0.5, color = "grey70") +
  
  geom_point_interactive(
    aes(
      x = logCPM, 
      y = logFC, 
      color = Late_Early, 
      tooltip = Tooltip
    ),
    size = 4
  ) + 
  
  # Scale colors
  scale_colour_manual(
    name = "Change direction: ",
    labels = c("Down", "NotSig", "Up"),
    values = c("blue", "black", "red")
  ) +
  
  # Convert the colour gradient from continuous to discrete
  scale_fill_viridis(discrete = T)

girafe(
  ggobj = volcano,
  width_svg = 8,
  height_svg = 8,
  options = list(
    opts_sizing(width = .7),
    opts_zoom(max = 5)
  )
)

```


